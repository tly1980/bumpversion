// Generated by CoffeeScript 1.6.2
(function() {
  'bumpversion will assume you always use git flow or hubflow.\nif you dont use git flow or hubflow, use -m and you have provide the version number.\nbumpversion should be called after you created a release branch.\nBasically, it will produce a VERSION.json in following structure:\n{\n	"main": # take from the current branch\n	"cache": # a self increment int. +1 everytime you call bumpversion\n	"timestamp": # timestamp,\n	"last_2_commits": # last 2 git commit\n}';
  var ArgumentParser, OLD_VERSION, OLD_VERSION_PATH, VERSION, args, exception, execSync, fs, i, parser, path, ret;

  execSync = require('execSync');

  fs = require('fs');

  path = require('path');

  ArgumentParser = require('argparse').ArgumentParser;

  parser = new ArgumentParser({
    version: '0.0.1',
    addHelp: true,
    description: 'Argparse examples: sub-commands'
  });

  parser.addArgument(['-m'], {
    help: 'Update the main version. If you do not specify version number, Main version will be take it as git branch by default.'
  });

  parser.addArgument(['-c'], {
    action: 'store',
    type: 'int',
    help: 'Update the cache version. If you not specify version number, it would be a self increment number'
  });

  parser.addArgument(['-q'], {
    help: 'quiet mode.',
    action: 'storeTrue'
  });

  parser.addArgument(['-lc'], {
    action: 'store',
    type: 'int',
    "default": 0,
    help: 'Update the last default commit'
  });

  args = parser.parseArgs();

  VERSION = {
    cache: 1,
    timestamp: new Date()
  };

  VERSION.main = args.m;

  if (args.m === null) {
    VERSION.main = execSync.exec("git rev-parse --abbrev-ref HEAD").stdout.replace('\n', '');
  }

  console.log('args', args);

  if (args.c === null) {
    try {
      OLD_VERSION_PATH = path.resolve(process.cwd(), './VERSION.json');
      OLD_VERSION = require(OLD_VERSION_PATH);
      VERSION.cache = OLD_VERSION.cache + 1;
    } catch (_error) {
      exception = _error;
      console.log("OLD_VERSION is not existed, will create new one");
    }
  } else {
    VERSION.cache = args.c;
  }

  if (args.lc > 0) {
    ret = execSync.exec("git log -" + args.lc + " --pretty=oneline");
    VERSION.last_commits = (function() {
      var _i, _len, _ref, _results;

      _ref = ret.stdout.split('\n');
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        if (i !== '') {
          _results.push(i);
        }
      }
      return _results;
    })();
  }

  fs.writeFileSync('./VERSION.json', JSON.stringify(VERSION, null, 4));

  if (args.q !== true) {
    console.log('version bumped to:\n ' + JSON.stringify(VERSION, null, 4));
  }

}).call(this);
