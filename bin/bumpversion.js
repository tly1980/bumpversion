// Generated by CoffeeScript 1.6.2
(function() {
  'bumpversion will assume you always use git flow or hubflow.\nif you dont use git flow or hubflow, use -m and you have provide the version number.\nbumpversion should be called after you created a release branch.\nBasically, it will produce a VERSION.json in following structure:\n{\n	"main": # take from the current branch\n	"cache": # a self increment int. +1 everytime you call bumpversion\n	"timestamp": # timestamp,\n	"last_2_commits": # last 2 git commit\n}';
  var ArgumentParser, BV_VERSION, OLD_VERSION, VERSION, VERSION_PATH, args, error, exception, execSync, fs, i, loadJSON, package_json, package_json_path, parser, path, ret,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  try {
    BV_VERSION = require('./bumpversion_VERSION.json');
  } catch (_error) {
    error = _error;
    BV_VERSION = {
      main: 'r0.1'
    };
  }

  execSync = require('execSync');

  fs = require('fs');

  path = require('path');

  ArgumentParser = require('argparse').ArgumentParser;

  parser = new ArgumentParser({
    version: BV_VERSION.main,
    addHelp: true,
    description: 'A tool to generate / bump the version to a JSON file.'
  });

  parser.addArgument(['-m'], {
    help: 'Update the main version. If you do not specify version number, Main version will be take it as git branch by default.'
  });

  parser.addArgument(['-c'], {
    action: 'store',
    type: 'int',
    help: 'Update the cache version. If you not specify version number, it would be a self increment number'
  });

  parser.addArgument(['-q'], {
    help: 'quiet mode.',
    action: 'storeTrue'
  });

  parser.addArgument(['-lc'], {
    action: 'store',
    type: 'int',
    defaultValue: 0,
    help: 'Update the last default commit'
  });

  parser.addArgument(['-f'], {
    action: 'store',
    defaultValue: 'VERSION.json',
    help: 'The file to store JSON'
  });

  parser.addArgument(['-x'], {
    action: 'store',
    defaultValue: '',
    help: 'Exclude the fields to be updated. Could be "m", "c" or "mc".'
  });

  parser.addArgument(['-p'], {
    action: 'storeTrue',
    defaultValue: false,
    help: 'Update the VERSION to package.json.'
  });

  args = parser.parseArgs();

  loadJSON = function(fpath) {
    var content;

    content = fs.readFileSync(fpath, 'utf8');
    return JSON.parse(content);
  };

  VERSION = {
    cache: 1,
    timestamp: new Date()
  };

  VERSION.main = args.m;

  if (args.m === null) {
    VERSION.main = execSync.exec("git rev-parse --abbrev-ref HEAD").stdout.replace('\n', '');
  }

  VERSION_PATH = path.resolve(process.cwd(), args.f);

  console.log("VERSION_PATH", VERSION_PATH);

  if (args.c === null) {
    try {
      OLD_VERSION = loadJSON(VERSION_PATH);
      VERSION.cache = OLD_VERSION.cache + 1;
    } catch (_error) {
      exception = _error;
      console.log("OLD_VERSION is not existed, will create new one");
    }
  } else {
    VERSION.cache = args.c;
  }

  if (args.lc > 0) {
    ret = execSync.exec("git log -" + args.lc + " --pretty=oneline");
    VERSION.last_commits = (function() {
      var _i, _len, _ref, _results;

      _ref = ret.stdout.split('\n');
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        if (i !== '') {
          _results.push(i);
        }
      }
      return _results;
    })();
  }

  if (__indexOf.call(args.x, 'c') >= 0) {
    if ((OLD_VERSION != null)) {
      VERSION.cache = OLD_VERSION.cache;
    }
  }

  if (__indexOf.call(args.x, 'm') >= 0) {
    if ((OLD_VERSION != null)) {
      VERSION.main = OLD_VERSION.main;
    }
  }

  fs.writeFileSync(VERSION_PATH, JSON.stringify(VERSION, null, 4));

  if (args.q !== true) {
    console.log('version bumped to:\n' + JSON.stringify(VERSION, null, 4) + '\n and save to : ' + VERSION_PATH);
  }

  if (args.p) {
    package_json_path = path.resolve(process.cwd(), './package.json');
    package_json = loadJSON(package_json_path);
    package_json.version = VERSION.main;
    fs.writeFileSync(package_json_path, JSON.stringify(package_json, null, 4));
    console.log('package.json is also being updated with version: ' + VERSION.main);
  }

}).call(this);
